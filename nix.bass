(provide [*config*]
  ; linux is redefined by this module, so be explicit
  (def bootstrap-linux
    linux)

  (def default-config
    {; image providing nix
     :nix-image (bootstrap-linux/nixos/nix)

     ; image providing nixery
     ;
     ; built via nix-build -A nixery-image in nixery repo
     :nixery-image (bootstrap-linux/basslang/nixery)
     :caddy-image (bootstrap-linux/caddy)})

  ; module configuration
  (def *config*
    (merge default-config (next *stdin* {}))))

(provide [result image with-cache]
  (use (.time)
       (.strings))

  (def *memos*
    *dir*/nix.lock)

  ; attaches the persistent /nix/ cache mount to the thunk
  (defn with-cache [thunk]
    (with-mount thunk cache-mount /nix/))

  (def cache-mount
    (let [img *config*:nix-image]
      (cache-dir (str "nix-cache:" img:repository ":" img:tag "@" img:digest))))

  ; an image with flakes and nix-command enabled
  (def image
    (from *config*:nix-image
      ; seed the cache with the initial /nix/ content
      ;
      ; (this will itself be cached)
      (with-mount ($ cp -anT /nix/ /cache/) cache-mount /cache/)

      ; enable flakes
      (with-cache ($ sh -c "echo accept-flake-config = true >> /etc/nix/nix.conf"))
      (with-cache ($ sh -c "echo experimental-features = nix-command flakes >> /etc/nix/nix.conf"))))

  ; returns a thunk path to ./result after running the given 'nix build' thunk
  ;
  ; The thunk runs with the /nix/ cache and must create ./result in its working
  ; directory.
  (defn result [thunk path]
    (subpath
      (from image
        (with-cache thunk)

        ; hoist the result out of /nix/store so we can pass it around as a
        ; regular thunk path
        ;
        ; having to cp here is unfortunate, but oh well
        (with-cache ($ cp -aL ./result $path)))
      path)))

(provide [linux]
  (use (.strings))

  (defn derivation [flake-ref name packages]
    (let [lines ["let"
            (str "  flake = builtins.getFlake " (json flake-ref) ";")
                 "  inputs = flake.inputs;"
                 "  pkgs = import inputs.nixpkgs {};"
                 "  stream = pkgs.dockerTools.streamLayeredImage {"
            (str "    name = " (json name) ";")
            (str "    contents = with pkgs; [" (strings:join " " packages) "];")
                 "    config = {"
                 "      Env = ["
                 "        \"PATH=/bin\""
                 "        \"SSL_CERT_FILE=${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt\""
                 "      ];"
                 "    };"
                 "  };"
                 "in"
                 "pkgs.runCommand \"write-docker-tar\" {} ''"
                 "  ${stream} > $out"
                 "''"]]
      (mkfile ./image.nix (strings:join "\n" lines))))

  (defn build-image [platform flake pkgs]
    (let [flake-ref (if (path? flake) "/flake" flake-ref)
          image-name (strings:join "/" (cons "nixpkgs" pkgs))
          image.nix (derivation flake-ref image-name pkgs)
          build-cmd (-> ($ nix build -f ./image.nix)
                        (with-mount image.nix ./image.nix))]
      {:platform platform
       :file (result (if (path? flake)
                       (-> build-cmd (with-mount flake /flake/))
                       build-cmd)
                     ./image.tar)}))

  (defn package-resolver [platform pkgs]
    (fn optional
      (case optional
        []
        (error "must configure :flake, which is a flake path or reference string")

        [pkg-or-opt & args]
        (cond
          (path? pkg-or-opt)
          (package-resolver platform (conj pkgs (path-name pkg-or-opt)))

          (symbol? pkg-or-opt)
          (let [{:flake flake} (list->scope optional)]
            (build-image platform flake pkgs))

          :else
          (error "invalid package resolver argument" :arg pkg-or-opt))

        _
        (error "invalid image path segment" :segment optional))))

  (def linux
    (package-resolver {:os "linux"} []))
  )

(provide [nixery]
  (defn nixery-srv [channel]
    (let [storage-cache (cache-dir "nixery-storage")]
      (from *config*:nixery-image
        (-> ($ nixery)
            (with-mount storage-cache /var/lib/nixery/)
            (with-port :registry 9110)
            (with-env {:NIXERY_STORAGE_BACKEND "filesystem"
                       :STORAGE_PATH "/var/lib/nixery"
                       :PORT "9110"
                       :WEB_DIR "/srv/www"
                       :NIXERY_CHANNEL channel})))))

  (defn https-nixery-srv [channel]
    (let [srv (nixery-srv channel)]
      (from *config*:caddy-image
        (-> ($ caddy run)
            (with-mount (mkfile ./Caddyfile ":443\ntls /caddy.crt /caddy.key\nreverse_proxy {\n  to {$PROXY_ADDR}\n}\n") ./Caddyfile)
            (with-env {:PROXY_ADDR (addr srv :registry "$host:$port")})
            (with-tls /caddy.crt /caddy.key)
            (with-port :registry 443)))))

  (defn nixery-resolver [thunk platform names]
    (fn optional
      (case optional
        []
        (let [repository (str "$host:$port/" (strings:join "/" names))]
          (resolve {:platform platform
                    :repository (addr thunk :registry repository)
                    :tag "latest"}))

        [dep]
        (nixery-resolver thunk platform (conj names (path-name dep)))

        _
        (error "invalid image path segment" :segment optional))))

  (defn locked-rev [flake.lock name]
    (let [lock (next (read flake.lock :json))
          node (name lock:nodes)]
      node:locked:rev))

  ; starts the nixery server if necessary and returns a module
  ;
  ; Takes a path to a flake.lock to read the nixpkgs revision from.
  ;
  ; The returned module extends the thunk's (start) module with a :linux path
  ; root for resolving images using the Nixery registry.
  (defn nixery [flake.lock]
    (let [channel (locked-rev flake.lock :nixpkgs)
          server (https-nixery-srv channel)]
      {:linux (nixery-resolver server {:os "linux"} [])})))
