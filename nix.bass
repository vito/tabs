(provide [*config* result image with-cache nixery]
  (use (.time)
       (.strings))

  (def *memos*
    *dir*/nix.lock)

  (def default-config
    {; image providing nix
     :nix-image (linux/nixos/nix)

     ; image providing nixery
     ;
     ; built via nix-build -A nixery-image in nixery repo
     :nixery-image (linux/basslang/nixery)})

  ; module configuration
  (def *config*
    (merge default-config (next *stdin* {})))

  ; attaches the persistent /nix/ cache mount to the thunk
  (defn with-cache [thunk]
    (with-mount thunk cache-mount /nix/))

  (def cache-mount
    (let [img *config*:nix-image]
      (cache-dir (str "nix-cache:" img:repository ":" img:tag "@" img:digest))))

  ; an image with flakes and nix-command enabled
  (def image
    (from *config*:nix-image
      ; seed the cache with the initial /nix/ content
      ;
      ; (this will itself be cached)
      (with-mount ($ cp -anT /nix/ /cache/) cache-mount /cache/)

      ; enable flakes
      (with-cache ($ sh -c "echo accept-flake-config = true >> /etc/nix/nix.conf"))
      (with-cache ($ sh -c "echo experimental-features = nix-command flakes >> /etc/nix/nix.conf"))))

  ; returns a thunk path to ./result after running the given 'nix build' thunk
  ;
  ; The thunk runs with the /nix/ cache and must create ./result in its working
  ; directory.
  (defn result [thunk path]
    (subpath
      (from image
        (with-cache thunk)

        ; hoist the result out of /nix/store so we can pass it around as a
        ; regular thunk path
        ;
        ; having to cp here is unfortunate, but oh well
        (with-cache ($ cp -aL ./result $path)))
      path))

  (defn nixery-srv [channel]
    (let [storage-cache (cache-dir "nixery-storage")]
      (from *config*:nixery-image
        (-> ($ nixery)
            (with-mount storage-cache /var/lib/nixery/)
            (with-ports {:registry 9110})
            (with-env {:NIXERY_STORAGE_BACKEND "filesystem"
                       :STORAGE_PATH "/var/lib/nixery"
                       :PORT "9110"
                       :WEB_DIR "/srv/www"
                       :NIXERY_CHANNEL channel})))))

  (defn nixery-resolver [platform names]
    (fn optional
      (case optional
        []
        (resolve {:platform platform
                  :repository (strings:join "/" names)
                  :tag "latest"})

        [dep]
        (nixery-resolver platform (conj names (path-name dep)))

        _
        (error "invalid image path segment" :segment optional))))

  (defn locked-rev [flake.lock name]
    (let [lock (next (read flake.lock :json))
          node (name lock:nodes)]
      node:locked:rev))

  ; starts the nixery server if necessary and returns an image path root
  ;
  ; Takes a path to a flake.lock to read the nixpkgs revision from.
  (defn nixery [flake.lock]
    (let [channel (locked-rev flake.lock :nixpkgs)
          addrs (serve (nixery-srv channel))]
      (nixery-resolver {:os "linux"} [addrs:registry]))))
